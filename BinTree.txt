перегрузили оператор сложения для шаблонных векторов:
циклом к первому вектору доклеиваем второй вектор


Empty:
возвращает пустое ли дерево (по сути пустая ли ссылка на корень)

Contains(val):
возвращает true если елемент есть в дереве, иначе false
проверяется через функцию Find(val).second (second - указатель на сам элемент)

Insert(val):
если такой элемент есть - выходим из функции
если дерево пустое создаем узел с val в корне
во временную переменную кидаем корень
 	если val меньше рута, спускаемся в левое поддерево (рут приравниваем к левому потомку)
	рекурсивно вызываем поиск(вызовется от нового рута)
	возвращаем на исконные места потомков рута и сам рут
	
	аналогично для val > root спускаемся вправо


Remove(val):
если корень и нет потомков, то удаляем рут
если лист дерева, то удаляем узел и ставим ссылку у родителя на nullptr
ксли есть правый(левый) потомок и нет левого(правого), то удаляем элемент и у родителя делаем ссылку на правый(левый) элемент удаленной ячейки
если есть оба потомка, находим в правом поддереве минимальный элемент(он будет больше рута, поэтому принцип построения бинарного дерева поиска сохранится)
удаляем его запоминая его значение
меняем значение в ячейке которую должны были удалить на найденное


Find (val) возвращает пару указателей на узлы(на родителя и на саму ячейку в которой лежит данный val):
обьявляем пару
если дерево пустое возвращаем два пустых указателя
если левый(правый) потомок равен val возвращаем пару (рут, левый(правый))

если val < значения root спусаемся влево (root = root->left)
рекурсивно вызываем поиск(поиск будет от нового рута)
возвращаем на место root
выходим из функции возвращая пару которую вернул поиск

аналогично для val > значения рута, идем в правое поддерево


RoundLrootR():
по сути нужно получить вектор выстроенный по возрастанию,
для этого должны идти снизу слева(с самого маленького элемента) вверх и добавляя вектор полученный рекурсивным вызовом функции из правого поддерева
сам код:
если лист, добавляем в результат
если слева пусто, а справа нет, добавляем рут в результат
если правое поддерево не пустое, вызываем функцию из правого поддерева и приклеиваем к результату справа


RoundRrootL():
то же только наоборот


Output: не трогаем, просто взяли с интернета и TreeDepth тоже тк она нужна только для Output


FormaingData:
начиная с рута добавляем элемент в вектор
заходим в левое поддерево и рекурсивно вызываем функцию
полученный вектор прибавляем справа к уже существующему
потом аналогично для левого поддерева
функция возвращает вектор по которому можно восстановить дерево просто пробежавшись по вектору и по очереди делая вставку в новое дерево

Deep()
оказывается такая же функция как и FormingData
те по факту обе делают обход в глубину


DeepOut - вывод вектора


RootPath()
ищем элемент: через Find получаем ссылку на ячейку и ссылку на ячейку родителя
добавляем в вектор ячейку 
вызываем Find от родителя и записываем каждую ячейку в вектор пока не дойдем до рута
возвращаем вектор

Path():
на вход подаются два вектора из RootPath
через цикл ищем первый слева элемент который есть в обоих векторах 
в новый вектор записываем значения ячеек до этого элемента
добавляем в него справа налево из второго вектора все ячейки от этого элемента до начала
возвращаем вектор

Wide() - обход в ширину
действия аналогичны RootPath только при каждом рекурсивном вызове в функцию передается интовая переменная
которая отвечает за глабину( на сколько далеко от корня находится вершина)
и узлы графа добавляются в вектор который находится в map под ключом глубины
те например имея дерево 1 3 4 (3 корень, 1 и 4 - потомки) 3 будет лежать в векторе под ключом 1,
а 1 и 4 в векторе под ключом 2

WideOut:
c помощью итератора пробегаемся по всем элементам map(векторам) и в каждом из них выводим все элементы


FindMinElem():
ищет в дереве минимальнвй элемент
по сути рекурсивно вызывается и спускается в левое поддерево пока ссылка на left != nullptr







